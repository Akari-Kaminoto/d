#!/usr/bin/python
# -*- coding: utf-8 -*-

import argparse
import codecs
import os
import sys
import re
import copy
import json
import subprocess
import shutil
from pathlib import Path
from distutils import dir_util
import csv
import difflib

# ディレクトリ作成
def make_dir(path):
    if (not os.path.exists(path)):
        os.makedirs(path, exist_ok=True)


# jsonファイル出力
def write_json(dict, filename):
    f = open(filename, 'w')
    json.dump(dict, f, ensure_ascii=False, indent=4, sort_keys=False, separators=(',', ': '))
    f.close()


# jsonファイル入力
def read_json(filename):
    f = open(filename, 'r')
    temp_json = json.load(f)
    f.close()
    return temp_json


# 単純list型txtの読み込み
def read_list_txt(filename):
    with open(filename) as f:
        struct_list = [line.rstrip() for line in f]
    return struct_list


# dif_init_element_public.hの読み込み
def read_init_element(dif_init_element_public_h):
    filter='CU4_SIZE_'
    keys=['1']
    vals=['1']
    with open(dif_init_element_public_h, encoding='cp932') as f:
        for line in f:
            if filter in line:
                line = line.rstrip().replace(' ', '\t')
                splited = line.split('\t')
                key = splited[1]
                val = splited[-1].replace('((U4)','').replace('UL)','')
                keys.append(key)
                vals.append(val)
        element_dict = dict(zip(keys, vals))
    return element_dict


# data_struct.csvの読み込み
def read_data_struct(data_struct_csv, struct_list):
    data_struct_dict={}
    with open(data_struct_csv, 'r', encoding='utf-8') as csvfile:
        csv_reader = csv.reader(csvfile, delimiter=',', quotechar='"', lineterminator='\r\n')
        curr_tagname=''
        curr_members={}
        header_cols = next(csv_reader)
        for row_read in csv_reader:
            # 構造体タグ名列の空白補完
            if row_read[0] != '':
                # タグ名更新前に前回のデータがあれば登録
                if curr_tagname != '' and len(curr_members)>0:
                    data_struct_dict.setdefault(curr_tagname, copy.deepcopy(curr_members))
                    curr_members.clear()
                # 現在のタグ名で初期化
                curr_tagname = row_read[0]
            # struct_listにあるもののみ抽出
            if curr_tagname in struct_list:
                membername=row_read[header_cols.index('メンバ名')]
                typename=row_read[header_cols.index('メンバデータ型')]
                elementnum=row_read[header_cols.index('要素数')]
                curr_members.setdefault(membername, {'typename':typename, 'elementnum':elementnum})
        # 最後のデータがたまっていれば登録
        if len(curr_members)>0:
            data_struct_dict.setdefault(curr_tagname, copy.deepcopy(curr_members))
    return data_struct_dict


# dif_struct_common_hの読み込み
def read_struct_common(dif_struct_common_h:str, struct_list:list):
    common_struct_dict={}
    start_key='typedef struct {'
    end_key='}'
    with open(dif_struct_common_h, encoding='cp932') as f:
        curr_members={}
        in_block = False
        in_commentout = False
        for line in f:
            line = line.rstrip()

            # 複数行コメント対応
            if '/*' in line and (not '*/' in line):
                in_commentout = True
            elif (not '/*' in line) and '*/' in line:
                in_commentout = False
                line = ''
            elif in_commentout:
                line = ''

            # 定義ブロック開始を検知
            if line == start_key:
                curr_members.clear()
                in_block = True

            # 定義ブロック終了を検知
            elif line[:1] == end_key and in_block:
                # struct名をパース
                match = re.search(r'ST_\w*',line)
                tagname = match.group(0)
                # struct_listにあるもののみ抽出
                if tagname[3:] in struct_list:
                    #print(tagname[3:])
                    common_struct_dict.setdefault(tagname, copy.deepcopy(curr_members))
                in_block = False
            
            # 定義ブロック内の処理
            elif in_block and line!='':
                # 構造体名は最後に判明するため毎回作る
                match = re.findall(r'\w*\w', line)
                typename = match[0]
                membername = match[1]
                match_element = re.findall(r'\[\S*\]', line)
                if match_element:
                    elementnum = match_element[0].replace('[','').replace(']','')
                else:
                    elementnum='1'
                curr_members.setdefault(membername, {'typename':typename, 'elementnum':elementnum})
    return common_struct_dict


# adxの型名からads_silsの型名へ変換
def convert_adx_typename_to_adssils_typename(adx_typename):
    convert_table = {
        "int8_t"   : "S1",
        "uint8_t"  : "U1",
        "int16_t"  : "S2",
        "uint16_t" : "U2",
        "int32_t"  : "S4",
        "uint32_t" : "U4",
        "int64_t"  : "S8",
        "uint64_t" : "U8",
        "float"    : "FL",
        "double"   : "DB",
        "char"               : "S1",
        "unsigned char"      : "U1",
        "uint8"              : "U1",
        "unsigned short"     : "U2",
        "uint32"             : "U4",
        "int"                : "S4",
        "unsigned int"       : "U4",
        "unsigned long"      : "U4",
        "__int64"            : "S8",
        "single"             : "FL",
        "RGB888"             : "RGB888",
        "boolean"            : "U1",
        "bool"               : "U1",
        "long"               : "S4",
        "enum"               : "S4",
        "int16"              : "S2",
        "int32"              : "S4",
        "uint16"             : "U2",
        "int8"               : "S1",
        "unsigned long long" : "U8",
        "long long"          : "S8"}

    if not adx_typename in convert_table.keys():
        # 型名が見つからない＝構造体名
        return 'ST_'+adx_typename, 'st_'
    else:
        # 型名変換
        return convert_table[adx_typename], convert_table[adx_typename].lower() + '_'

# 20tmの配列長定義名から実数へ変換
def convert_elementname_to_int(elementname, element_dict):
    if not elementname in element_dict:
        print('    Error: array element name not found. {0}'.format(elementname))
        return 0
    else:
        return int(element_dict[elementname])


# adxの定義と20tmの定義を比較
def compare_struct_definition(data_struct_csv, structlist_txt, dif_struct_common_h, dif_init_element_public_h):
    struct_list = read_list_txt(structlist_txt)
    element_dict = read_init_element(dif_init_element_public_h)
    data_struct_dict = read_data_struct(data_struct_csv, struct_list)
    common_struct_dict = read_struct_common(dif_struct_common_h, struct_list)

    # data_struct_dictを軸にcommon_struct_dictを照合
    for data_tagname, data_members in data_struct_dict.items():
        print('* {0}'.format(data_tagname))
        is_ok = True
        # key,itemはcommon_struct_dictへ合わせる方向に変換してから比較
        tagname = 'ST_'+data_tagname
        # 同じ構造体タグ名を引き当て
        if not tagname in common_struct_dict.keys():
            # 構造体タグ名が見つからない
            is_ok = False
            print('    * Error : struct name not found in dif_struct_common.h.')
        else:
            # 構造体メンバー数の比較
            common_members = common_struct_dict[tagname]
            if len(data_members) != len(common_members):
                 # 構造体メンバー数の不一致
                 is_ok = False
            # 各構造体メンバー同士の比較
            for data_membername, data_type_elem in data_members.items():
                data_elementnum = int(data_type_elem['elementnum'])
                data_typename = data_type_elem['typename']
                typename, prefix = convert_adx_typename_to_adssils_typename(data_typename)
                if data_elementnum != 1:
                    prefix = 'a' + prefix
                membername = prefix + data_membername
                if membername not in common_members.keys():
                    # 構造体メンバ名が見つからない
                    is_ok = False
                else:
                    common_type_elem = common_members[membername]
                    common_typename = common_type_elem['typename']
                    common_elementnum = convert_elementname_to_int(common_type_elem['elementnum'], element_dict)
                    if typename != common_typename:
                        # メンバー変数の型の不一致
                        is_ok = False
                    if data_elementnum != common_elementnum:
                        # 配列長の不一致
                        is_ok = False

            # 差異が検出された
            if not is_ok:
                print('    * Error : The structure definitions are different.')
                # data_membersとcommon_membersをdif_struct_common.hスタイルの構造体定義テキストを生成してdiflibにかける
                data_text_list = ['typedef struct {\n']
                for data_membername, data_type_elem in data_members.items():
                    data_elementnum = int(data_type_elem['elementnum'])
                    data_typename = data_type_elem['typename']
                    typename, prefix = convert_adx_typename_to_adssils_typename(data_typename)
                    arrayinfo=""
                    if data_elementnum != 1:
                        prefix = 'a' + prefix
                        arrayinfo = '[{0}]'.format(data_elementnum)
                    membername = prefix + data_membername
                    data_text_list.append('\t{0}\t{1}{2};\n'.format(typename, membername, arrayinfo))
                data_text_list.append('}} {0};\n'.format(tagname))

                common_text_list = ['typedef struct {\n']
                for common_membername, common_type_elem in common_members.items():
                    common_elementnum = convert_elementname_to_int(common_type_elem['elementnum'], element_dict)
                    common_typename = common_type_elem['typename']
                    arrayinfo=""
                    if common_elementnum != 1:
                        arrayinfo = '[{0}]'.format(common_elementnum)
                    common_text_list.append('\t{0}\t{1}{2};\n'.format(common_typename, common_membername, arrayinfo))
                common_text_list.append('}} {0};\n'.format(tagname))

                max_n = max(len(data_text_list),len(common_text_list))

                # ソートして順不同比較を行う場合以下2行コメントアウト解除
                #data_text_list.sort()
                #common_text_list.sort()

                result_gen = difflib.unified_diff(
                    data_text_list, common_text_list, 
                    fromfile='adx/dif_struct_common.h(convert_from_DATASTRUCT.CSV)', 
                    tofile='20tm/dif_struct_common.h', 
                    lineterm='', n=max_n)
                # markdownに表示できるように出力
                print('```diff')
                for line in result_gen:
                    print(line.rstrip())
                print('```')

        if is_ok:
            print('    * OK')

def main():
    # パラメータパーサ作成
    parser = argparse.ArgumentParser(description='dxの構造体定義とads_slilsの構造体定義を比較')

    # パラメータ：入力
    parser.add_argument('-d', '--data_struct_csv', type=str, required=True,
                        help='DATA_STRUCT.csv path. (mandatory)', dest='data_struct_csv')
    parser.add_argument('-l', '--structlist_txt', type=str, required=True,
                        help='structlist.txt path. (mandatory)', dest='structlist_txt')
    parser.add_argument('-s', '--dif_struct_common_h', type=str, required=True,
                        help='dif_struct_common.h path. (mandatory)', dest='dif_struct_common_h')
    parser.add_argument('-e', '--dif_init_element_public_h', type=str, required=True,
                        help='dif_init_element_public.h path. (mandatory)', dest='dif_init_element_public_h')

    # パラメータパーサ登録
    args = parser.parse_args()
    data_struct_csv = args.data_struct_csv
    structlist_txt = args.structlist_txt
    dif_struct_common_h = args.dif_struct_common_h
    dif_init_element_public_h = args.dif_init_element_public_h

    # ファイル存在チェック
    if not os.path.exists(data_struct_csv):
        print('error : data_struct_csv not found. ' + data_struct_csv)
        exit(1)
    if not os.path.exists(structlist_txt):
        print('error : structlist_txt not found. ' + structlist_txt)
        exit(1)
    if not os.path.exists(dif_struct_common_h):
        print('error : dif_struct_common_h not found. ' + dif_struct_common_h)
        exit(1)
    if not os.path.exists(dif_init_element_public_h):
        print('error : dif_init_element_public_h not found. ' + dif_init_element_public_h)
        exit(1)

    # adxの構造体定義とads_slilsの構造体定義を比較
    compare_struct_definition(data_struct_csv, structlist_txt, dif_struct_common_h, dif_init_element_public_h)

    print('\n---- 完了 ----\n')


if __name__ == '__main__':
    main()
