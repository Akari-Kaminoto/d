/****************************************************************************/
/* ファイル名	: appfw_recv_func.c											*/
/*--------------------------------------------------------------------------*/
/* モジュール名	: appfw_recv 											*/
/*--------------------------------------------------------------------------*/
/* 機能			: 機能呼び出し												*/
/*--------------------------------------------------------------------------*/
/* 備考			:															*/
/*--------------------------------------------------------------------------*/
/****************************************************************************/
/*	  Include																*/
/****************************************************************************/
#undef __STRICT_ANSI__
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>
#include "type_sils.h"
#include <sys/socket.h>
#include <sys/select.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <fcntl.h>
#include <errno.h>
#include <poll.h>

#include <dif/common/dif_struct_common.h>
#include "../../appfw_data/pub/appfw_data.h"
#include "../pub/appfw_recv_func.h"
#include "appfw_recv_crc32.h"

/****************************************************************************/
/*					スタティック関数宣言									*/
/****************************************************************************/
#define APPFW_RECV_PORT 15010

#define HEADER_DELIMITER 0xffffffff
#define HEADER_SIZE  12
#define ACCEPT_TIMEOUT 10 //sec
#define RECEIVE_TIMEOUT 10 //sec
#define ACCEPT_TIMEOUT_MS (ACCEPT_TIMEOUT*1000) //msec
#define RECEIVE_TIMEOUT_MS (RECEIVE_TIMEOUT*1000) //msec

#define MIN(a, b) ((a)<(b)?(a):(b))
#define MAX(a, b) ((a)>(b)?(a):(b))

static int sock = -1;
static int sock_accept = -1;
static bool sock_connected = false;
static uint8_t *temp_recv_buf=NULL;
static uint8_t *temp_serialize_buf = NULL;
static size_t max_buf_size = 0;

typedef union {
  /**BUFFER_SIZE_LIST_START**/
  char m10[CARSTATE_SERIALIZED_SIZE];
  /**BUFFER_SIZE_LIST_END**/
} BufferSizeList;

typedef size_t (*deserialize_func_ptr)(void *data, void *buffer);
typedef struct{
  uint32_t data_label;
  void *output_buffer;
  deserialize_func_ptr des_func;
  uint32_t serialized_size;
} DataInfo;

typedef size_t (*serialize_func_ptr)(void *buffer, const void *data, size_t max_buffer_size);
static void PrintCrc32(void *data, serialize_func_ptr func, uint32_t data_label);


/****************************************************************************/
/* 関数名		:	fn_appfw_recv_init								*/
/*--------------------------------------------------------------------------*/
/* 機能			:	appfw_recv_init										*/
/*--------------------------------------------------------------------------*/
/* 引数			: なし														*/
/*--------------------------------------------------------------------------*/
/* 戻り値		: なし														*/
/****************************************************************************/
VD	fn_appfw_recv_init(VD)
{
  LINUX_PRINT_OUT("%s:%d start-------------\n", __FUNCTION__, __LINE__);

  struct sockaddr_in addr;

  //socket初期化
  sock = socket(AF_INET, SOCK_STREAM, 0);
  if (sock < 0) {
    Slog_Error("socket failed.");
    return;
  }
  int yes = 1;
  setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (const char *)&yes, sizeof(yes));

  //port初期化
  addr.sin_family = AF_INET;
  addr.sin_port = htons(APPFW_RECV_PORT);
  addr.sin_addr.s_addr = INADDR_ANY;
  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) != 0) {
    Slog_Error("bind error.");
    return;
  }
  if (listen(sock, 1) != 0) {
    Slog_Error("listen error.");
    return;
  }

  max_buf_size = sizeof(BufferSizeList);

  //シリアライズサイズメモリ確保
  temp_recv_buf = malloc(max_buf_size);

  //crc32初期化
  fpmw_recv_crc32_init();

  LINUX_PRINT_OUT("%s:%d end-------------\n", __FUNCTION__, __LINE__);
	return;
}

/****************************************************************************/
/* 関数名		:	fn_appfw_recv_compute							*/
/*--------------------------------------------------------------------------*/
/* 機能			:	fn_appfw_recv_compute											*/
/*--------------------------------------------------------------------------*/
/* 引数			: なし														*/
/*--------------------------------------------------------------------------*/
/* 戻り値		: なし														*/
/****************************************************************************/
VD	fn_appfw_recv_compute(VD)
{
  LINUX_PRINT_OUT("%s:%d start-------------\n", __FUNCTION__, __LINE__);

  size_t i;

  //ダミーのADXDigsmStatus生成
  ST_ADXDigsmStatus adx_digsm_status = {0};
  ADXDigsmStatus *recv_adx_digsm_status = (ADXDigsmStatus*)&adx_digsm_status;

  DataInfo data_info_list[] = {
    /**DATA_INFO_LIST_START**/
    {kIoDataLabelADXDigsmStatus, recv_adx_digsm_status, (deserialize_func_ptr)&DeserializeADXDigsmStatus, ADXDIGSMSTATUS_SERIALIZED_SIZE},
    /**DATA_INFO_LIST_END**/
  };
  size_t data_info_list_count = (size_t)(sizeof(data_info_list)/sizeof(DataInfo));

  if (sock < 0) {
    Slog_Error("socket error.");
    return;
  }

  //未接続時は接続要求を待つ
  if (sock_connected == false) {
    struct pollfd fds = {0};
    fds.fd = sock;
    fds.events = POLLIN | POLLERR;
    int pret = poll(&fds, 1, ACCEPT_TIMEOUT_MS);
    if (pret < 0 || (fds.revents & POLLIN) == 0) {
      //接続要求待ちタイムアウト or エラー -> retry
      return;
    }

    //接続要求あり
    struct sockaddr_in client;
    socklen_t len = (socklen_t)sizeof(client);
    sock_accept = accept(sock, (struct sockaddr *)&client, (socklen_t*)&len);
    if (sock_accept < 0) {
      Slog_Error("accept error.");
      return;
    }
    sock_connected = true;
    Slog_Info("connected.");
  }

  //受信
  uint32_t header_len_received = 0;
  uint32_t data_len_expect = 0;
  uint32_t data_len_received = 0;
  uint32_t data_label = 0;
  char header_buf[HEADER_SIZE] = {0};

  while(1) {

    struct pollfd fds = {0};
    fds.fd = sock_accept;
    fds.events = POLLIN | POLLERR;
    int pret = poll(&fds, 1, RECEIVE_TIMEOUT_MS);
    if (pret == 0 && (fds.revents & POLLIN) == 0){
      //timeout
      if ((header_len_received>0) || (data_len_received>0)) {
        //メッセージ受信途中のタイムアウトはエラー
        Slog_Error("receiving timeout error");
      }
      return;
    }
    if (pret < 0) {
      if (errno == EINTR) {
        Slog_Debug("poll() EINTR");
        continue;
      }
      Slog_Error("poll: %s", strerror(errno));
      return;
    }

    if (header_len_received < HEADER_SIZE){
      //ヘッダの抽出
      uint32_t len_read = HEADER_SIZE-header_len_received;
      errno = 0;
      int32_t len_result = (int32_t)read(sock_accept, &header_buf[header_len_received], len_read);
      if (len_result == 0) {
        //コネクション切断
        Slog_Info("connection closed. ret:0, %s", strerror(errno));
        sock_connected = false;
        close(sock_accept);
        sock_accept = -1;
        return;
      } else if (len_result < 0) {
        if (errno == EINTR) {
          Slog_Debug("read() EINTR");
          continue;
        }
        //ソケットエラー
        Slog_Info("connection closed. %s", strerror(errno));
        sock_connected = false;
        close(sock_accept);
        sock_accept = -1;
        return;
      }
      header_len_received += (uint32_t)len_result;
      if (header_len_received == HEADER_SIZE) {
        uint32_t delim = (*((uint32_t*)(void*)&header_buf[0]));
        if (delim == HEADER_DELIMITER){
          //ヘッダがそろったらデータ長とIDを取得
          data_label      = (*((uint32_t*)(void*)&header_buf[4]));
          data_len_expect = (*((uint32_t*)(void*)&header_buf[8]));
          //未定義の大きいデータが送信された場合は一旦バッファを拡張（データラベル判定時に破棄する）
          if (max_buf_size < data_len_expect) {
            free(temp_recv_buf);
            max_buf_size = data_len_expect;
            temp_recv_buf = malloc(max_buf_size);
          }
          if (data_len_expect <= 0) {
            //データサイズのエラー
            Slog_Error("data size error.");
            return;
          }
        } else {
          //ヘッダのデリミタ照合エラー
          Slog_Error("unknown header delimiter");
          return;
        }
      }

    } else if (data_len_expect > 0) {
      //データの抽出
      uint32_t len_read = data_len_expect - data_len_received;
      int32_t len_result = (int32_t)read(sock_accept, &temp_recv_buf[data_len_received], len_read);
      if (len_result <= 0) {
        if (errno == EINTR) {
          Slog_Debug("read() EINTR");
          continue;
        }
        //ソケットエラーかデータ受信途中でコネクション切断エラー
        Slog_Error("read error. %s", strerror(errno));
        sock_connected = false;
        close(sock_accept);
        sock_accept = -1;
        return;
      }
      data_len_received += (uint32_t)len_result;
      if (data_len_received == data_len_expect) {
        //１パケット受信完了
        bool found = false;
        for (i=0; i<data_info_list_count; i++) {
          if (data_label == data_info_list[i].data_label) {
            found = true;
            if (data_len_received == data_info_list[i].serialized_size) {
              (data_info_list[i].des_func)(data_info_list[i].output_buffer, (void*)temp_recv_buf);
              //プロトタイプはkIoDataLabelADXDigsmStatusのみ
              PrintCrc32((void*)&adx_digsm_status, (serialize_func_ptr)&SerializeADXDigsmStatus, kIoDataLabelADXDigsmStatus);
              break;
            } else {
              Slog_Error("incompatible data size. (data label %d)", data_label);
              break;
            }
          }
        }
        if (found == false) {
          Slog_Error("unknown data label (%d)", data_label);
        }
        LINUX_PRINT_OUT("%s:%d end-------------\n", __FUNCTION__, __LINE__);
        return;
      }
    }
  }

  LINUX_PRINT_OUT("%s:%d end-------------\n", __FUNCTION__, __LINE__);
  return;
}

/****************************************************************************/
/* 関数名		:	PrintCrc32							*/
/*--------------------------------------------------------------------------*/
/* 機能			:	ダミーデータ取得											*/
/*--------------------------------------------------------------------------*/
/* 引数			: 略														*/
/*--------------------------------------------------------------------------*/
/* 戻り値		: 略														*/
/****************************************************************************/
static void PrintCrc32(void *data, serialize_func_ptr func, uint32_t data_label)
{
  if (temp_serialize_buf==NULL) {
      temp_serialize_buf = malloc(max_buf_size);
  }
  //serialize -> crc32 -> print
  size_t serialized_size = (func)(temp_serialize_buf, data, max_buf_size);
  uint32_t crc = fpmw_recv_crc32(temp_serialize_buf, serialized_size);
  printf("dataid:%"PRIu32" crc32:0x%08"PRIx32"\n", data_label, crc);
}
