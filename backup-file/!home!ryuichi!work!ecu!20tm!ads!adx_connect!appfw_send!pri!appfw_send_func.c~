/****************************************************************************/
/* ファイル名	: appfw_send_func.c											*/
/*--------------------------------------------------------------------------*/
/* モジュール名	: appfw_send 											*/
/*--------------------------------------------------------------------------*/
/* 機能			: 機能呼び出し												*/
/*--------------------------------------------------------------------------*/
/* 備考			:															*/
/*--------------------------------------------------------------------------*/
/****************************************************************************/
/*	  Include																*/
/****************************************************************************/
#include <arpa/inet.h>
#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>
#include <netinet/in.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>

#include "type_sils.h"
#include <dif/common/dif_struct_common.h>
#include "../../appfw_data/pub/appfw_data.h"
#include "../pub/appfw_send_func.h"
#include "../../appfw_send/pri/appfw_send_crc32.h"

/****************************************************************************/
/*					スタティック関数宣言									*/
/****************************************************************************/
#define APPFW_SEND_IPADDR "127.0.0.1"
#define APPFW_SEND_PORT 15000

#define HEADER_DELIMITER 0xffffffff
#define HEADER_SIZE 12
#define CONNECT_TRY_MAX 3
#define CONNECT_TRY_INTERVAL 1

#define MIN(a, b) ((a) < (b) ? (a) : (b))
#define MAX(a, b) ((a) > (b) ? (a) : (b))

static int sock = -1;
static bool sock_connected = false;
static struct sockaddr_in server;
static uint8_t *temp_send_buf = NULL;
static uint8_t *temp_serialize_buf = NULL;
static size_t max_buf_size = 0;

typedef size_t (*serialize_func_ptr)(void *buffer, const void *data,
                                     size_t max_buffer_size);

typedef union {
  /**BUFFER_SIZE_LIST_START**/
  char m1[CARSTATE_SERIALIZED_SIZE];
  /**BUFFER_SIZE_LIST_END**/
} BufferSizeList;

typedef struct {
  uint32_t data_label;
  void *input_buffer;
  serialize_func_ptr ser_func;
} DataInfo;

static bool SendMessageData(const void *msg, serialize_func_ptr func, uint32_t data_id);
static bool GetData(void *data, uint32_t len);
static void PrintCrc32(void *data, serialize_func_ptr func, uint32_t data_label);

/****************************************************************************/
/* 関数名		:	fn_appfw_send_init								*/
/*--------------------------------------------------------------------------*/
/* 機能			:	appfw_send_init										*/
/*--------------------------------------------------------------------------*/
/* 引数			: なし														*/
/*--------------------------------------------------------------------------*/
/* 戻り値		: なし														*/
/****************************************************************************/
VD	fn_appfw_send_init(VD)
{
  LINUX_PRINT_OUT("%s:%d start-------------end\n", __FUNCTION__, __LINE__);
  
  //socket初期化
  sock = socket(AF_INET, SOCK_STREAM, 0);
  if (sock < 0) {
    Slog_Error("socket failed.");
    return;
  }

  //inet_addr設定
  char *ipaddr = APPFW_SEND_IPADDR;
  server.sin_family = AF_INET;
  server.sin_port = htons(APPFW_SEND_PORT);
  server.sin_addr.s_addr = inet_addr((const char *)ipaddr);
  if (server.sin_addr.s_addr == 0xffffffff) {
    Slog_Error("inet_addr failed.");
    return;
  }

  //シリアライズデータサイズ最大値を取得する
  max_buf_size = sizeof(BufferSizeList);

  //シリアライズサイズメモリ確保
  temp_send_buf = malloc(max_buf_size + HEADER_SIZE);
  *((uint32_t *)(void *)&temp_send_buf[0]) = (HEADER_DELIMITER);

  //疑似乱数初期化
  srand(0);
  //crc32初期化
  fpmw_send_crc32_init();

  LINUX_PRINT_OUT("%s:%d end-------------\n", __FUNCTION__, __LINE__);
  return;
}

/****************************************************************************/
/* 関数名		:	fn_appfw_send_compute							*/
/*--------------------------------------------------------------------------*/
/* 機能			:	fn_appfw_send_compute											*/
/*--------------------------------------------------------------------------*/
/* 引数			: なし														*/
/*--------------------------------------------------------------------------*/
/* 戻り値		: なし														*/
/****************************************************************************/
VD	fn_appfw_send_compute(VD)
{
  LINUX_PRINT_OUT("%s:%d start-------------\n", __FUNCTION__, __LINE__);

  size_t i;

  //ダミーのCarData
  ST_CarState car_state;
  CarState *send_car_state = (CarState*)&car_state;

  if (sock < 0) {
    Slog_Error("socket error.");
    return;
  }

  DataInfo data_info_list[] = {
      /**DATA_INFO_LIST_START**/
      {kIoDataLabelCarState, (void *)send_car_state,
       (serialize_func_ptr)&SerializeCarState},
      /**DATA_INFO_LIST_END**/
  };
  size_t data_info_list_count =
      (size_t)(sizeof(data_info_list) / sizeof(DataInfo));

  //コネクション状態チェック
  uint32_t dummybuf;
  int32_t recv_len =
      recv(sock, &dummybuf, sizeof(dummybuf), MSG_DONTWAIT | MSG_PEEK);
  if (recv_len != -1 || errno != EAGAIN) {
    if (sock_connected == true) {
      Slog_Info("connection closed.");
      sock_connected = false;
    }
  }

  //コネクション切断時は再接続
  if (sock_connected == false) {
    close(sock);
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) {
      Slog_Error("socket failed.");
      return;
    }
    int try
      ;
    for (try = 0; try < CONNECT_TRY_MAX; try ++) {
      if (connect(sock, (struct sockaddr *)&server, sizeof(server)) == 0) {
        sock_connected = true;
        Slog_Info("connected.");
        break;
      }
      sleep(CONNECT_TRY_INTERVAL);
    }
    if (sock_connected == false) {
      Slog_Error("connect failed.");
      return;
    }
  }

  //ダミーのテストデータを生成してcrc32表示する
  GetData((void*)&car_state, sizeof(ST_CarState));
  PrintCrc32((void*)&car_state, (serialize_func_ptr)&SerializeCarState, kIoDataLabelCarState);

  //各データの配信フラグをチェックして送信
  for (i = 0; i < data_info_list_count; i++) {
    bool is_updated = true;
    // １データ限定常時true
    //Appfw_MsgUtilIsUpdated(data_info_list[i].input_buffer, &is_updated);
    if (is_updated) {
      bool ret = SendMessageData((const void *)data_info_list[i].input_buffer,
                                 (serialize_func_ptr)data_info_list[i].ser_func,
                                 data_info_list[i].data_label);
      if (!ret) {
        return;
      }
    }
  }

  LINUX_PRINT_OUT("%s:%d end-------------\n", __FUNCTION__, __LINE__);
  return;
}

/****************************************************************************/
/* 関数名		:	GetData							*/
/*--------------------------------------------------------------------------*/
/* 機能			:	ダミーデータ取得											*/
/*--------------------------------------------------------------------------*/
/* 引数			: 略														*/
/*--------------------------------------------------------------------------*/
/* 戻り値		: 略														*/
/****************************************************************************/
static bool GetData(void *data, uint32_t len)
{
  char *ptr = (char*)data;
  for (uint32_t i=0; i<len; i++) {
    ptr[i] = (char)(rand()&0x01);
  }
}

/****************************************************************************/
/* 関数名		:	PrintCrc32							*/
/*--------------------------------------------------------------------------*/
/* 機能			:	ダミーデータ取得											*/
/*--------------------------------------------------------------------------*/
/* 引数			: 略														*/
/*--------------------------------------------------------------------------*/
/* 戻り値		: 略														*/
/****************************************************************************/
static void PrintCrc32(void *data, serialize_func_ptr func, uint32_t data_label)
{
  if (temp_serialize_buf==NULL) {
      temp_serialize_buf = malloc(max_buf_size);
  }
  //serialize -> crc32 -> print
  size_t serialized_size = (func)(temp_serialize_buf, data, max_buf_size);
  uint32_t crc = fpmw_send_crc32(temp_serialize_buf, serialized_size);
  printf("dataid:%"PRIu32" crc32:0x%08"PRIx32"\n", data_label, crc);
}

/****************************************************************************/
/* 関数名		:	SendMessageData							*/
/*--------------------------------------------------------------------------*/
/* 機能			:	汎用データ型送信											*/
/*--------------------------------------------------------------------------*/
/* 引数			: 略														*/
/*--------------------------------------------------------------------------*/
/* 戻り値		: 略														*/
/****************************************************************************/
static bool SendMessageData(const void *msg, serialize_func_ptr func,
                            uint32_t data_id) {
  //シリアライズ関数
  size_t serialized_size =
      (func)(&temp_send_buf[HEADER_SIZE], msg, max_buf_size);
  if (serialized_size == 0) {
    return false;
  }

  //ヘッダ情報
  *((uint32_t *)(void *)&temp_send_buf[4]) = (uint32_t)data_id;
  *((uint32_t *)(void *)&temp_send_buf[8]) = (uint32_t)serialized_size;

  //socket送信
  size_t remain = serialized_size + HEADER_SIZE;
  size_t sended = 0;
  errno = 0;
  do {
    int32_t send_len = (int32_t)send(sock, temp_send_buf + sended, remain, 0);
    if (send_len < 0 && errno != EINTR) {
      sock_connected = false;
      Slog_Error("send failed. %s", strerror(errno));
      Slog_Info("connection closed.");
      return false;
    }
    if (send_len >= 0) {
      if ((size_t)send_len != remain) {
        //(注意)このログが出力されるケースではTCPの伝送が間に合っていない可能性がある
        Slog_Warn("data_id:%" PRIu32 ", send() %zubytes but return %" PRId32
                  "bytes. resending...",
                  data_id, remain, send_len);
      }
      remain -= send_len;
      sended += send_len;
    }
  } while (remain);
  return true;
}
